#!/bin/bash
# overrides default `set -e`: Do not exit if a command fails.
set +e

verbose=${JOB_VERBOSE:-false}
if [ "$verbose" != "false" ]; then
  set -x
  export
fi

if [ "$JOB_PRE_HOOK" != "" ]; then
  echo "Running pre hook command: $JOB_PRE_HOOK"
  eval "$JOB_PRE_HOOK"
fi

# App variables
pull_request_number=$JOB_PULL_REQUEST_NUMBER
branch_name=$JOB_BRANCH_NAME
repo_name=$JOB_REPO_NAME
repo_owner=$JOB_REPO_OWNER
job_url=$JOB_URL

# Job variables
prefix=${JOB_PREFIX:-re}
kube_config_file=${JOB_KUBE_CONFIG_FILE:-$HOME/.kube/config}
name="$prefix-${JOB_ID_OVERRIDE:-$JOB_ID}"
short_name=$(echo "$name" | cut -c1-15 | awk '{print tolower($0)}')
hash=$(echo "$name" | rhash -p "%c" -)
namespace=$short_name-$hash
kube_context=$JOB_KUBE_CONTEXT
base_overlay_path=${JOB_BASE_OVERLAY_PATH:-"src/job/resources/base"}
overlay_path="$JOB_OVERLAY_PATH/."
overlay_target_dir=$JOB_OVERLAY_TARGET_DIR

updated_at=$(date +%s)

print_preinstall_message() {
  if [ "$JOB_MESSAGE" != "" ]; then
    printf "%s\n" "$JOB_MESSAGE $namespace"
  fi
}

config_context() {
  # kubectl locks the config for each execution. To workaround
  # and allow multiple concurrent kubectl executions we copy the config
  scoped_kubeconfig_file=$kube_config_file-$namespace
  cp "$kube_config_file" "$scoped_kubeconfig_file"
  export KUBECONFIG=${scoped_kubeconfig_file}

  if [ "$kube_context" != "" ]; then
    kubectl config use-context "$kube_context"
  fi
}

install_resources () {
  # Prepare directory structure and copy files
  work_dir=$(mktemp -d)

  # If we don't have a overlay to apply, we just run from base overlay
  cp -R "$base_overlay_path" "$work_dir"
  if [ "$overlay_path" != "" ]; then
    cp -R "$overlay_path" "$work_dir"
  fi

  # Apply variable substituion on patches
  for f in "$work_dir"/**/patches/*.json
  do
    JOB_NAMESPACE=$namespace \
    envsubst < "$f" | sponge "$f";
    if [ "$verbose" = "true" ]; then
      cat "$f"
    fi
  done

  # Accessing the folder with the kustomize files
  if [ "$overlay_target_dir" != "" ]; then
    cd "$work_dir/$overlay_target_dir"
  else
    cd "$work_dir/base"
  fi

  kustomize edit set namespace "$namespace"
  kustomize edit set namesuffix -- "-$updated_at"
  kustomize edit add annotation --force \
  app.kubernetes.io/instance:"$namespace" \
  app.kubernetes.io/pull_request_number:"$pull_request_number" \
  app.kubernetes.io/branch_name:"$branch_name" \
  app.kubernetes.io/repository_name:"$repo_name" \
  app.kubernetes.io/repository_owner:"$repo_owner" \
  app.kubernetes.io/updated_at:"$updated_at" \
  app.kubernetes.io/job_url:'"'$job_url'"'

  if [ "$verbose" = "true" ]; then
    kustomize build
  fi

  # Considering that we can run a job without having the namespace previously created
  # here we are making sure and if needed creating the namespace
  output=$(kubectl get namespace "$namespace" --ignore-not-found)
  if [[ $output = "" ]]; then
    echo "Namespace "$namespace" is not found, creating it";
    kubectl create namespace "$namespace";
  else
    echo "Namespace "$namespace" is found, no creation is required";
  fi

  # Apply changes generated by kustomize
  kustomize build | kubectl apply -f - -n "$namespace" --wait=true

  if [ "$verbose" = "false" ]; then
    exit 1;
  else
    echo "[VERBOSE] Showing Pods Logs"
    for pod_names in $(kubectl get jobs.batch --no-headers -o custom-columns=":metadata.name" -n "$namespace")
    do
      echo "Logs from Pod '"$pod_names"'" "in" the Namespace "'"$namespace"':"
      kubectl -n "$namespace" logs "$pod_names" --all-containers=true
    done
    exit 1;
  fi
}

print_preinstall_message
config_context
install_resources

if [ "$JOB_POST_HOOK" != "" ]; then
  echo "Running post hook command: $JOB_POST_HOOK"
  eval "$JOB_POST_HOOK"
fi
