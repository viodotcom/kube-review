#!/bin/bash
# exit if any command fails
set -e

verbose=${KR_VERBOSE:-false}
if [ "$verbose" != "false" ]; then
  set -x
  export
fi

if [ "$KR_PRE_HOOK" != "" ]; then
  echo "Running pre hook command: $KR_PRE_HOOK"
  eval "$KR_PRE_HOOK"
fi

# App variables
pull_request_number=$KR_PULL_REQUEST_NUMBER
branch_name=$KR_BRANCH_NAME
repo_name=$KR_REPO_NAME
repo_owner=$KR_REPO_OWNER
job_url=$KR_JOB_URL

# Kube Review variables
prefix=${KR_PREFIX:-re}
kube_config_file=${KR_KUBE_CONFIG_FILE:-$HOME/.kube/config}
name="$prefix-${KR_ID_OVERRIDE:-$KR_ID}"
short_name=$(echo "$name" | cut -c1-15 | awk '{print tolower($0)}')
hash=$(echo "$name" | rhash -p "%c" -)
namespace=$short_name-$hash
is_ephemeral=${KR_IS_EPHEMERAL:-true}
host=$namespace.$KR_DOMAIN
url=https://$host
kube_context=$KR_KUBE_CONTEXT
test_connection=${KR_TEST_CONNECTION:-true}
test_connection_url_path=${KR_TEST_CONNECTION_URL_PATH:-"/"}
shared_path=$KR_SHARED_PATH
base_overlay_path=${KR_BASE_OVERLAY_PATH:-"src/deploy/resources/base"}
overlay_path="$KR_OVERLAY_PATH/."
overlay_target_dir=$KR_OVERLAY_TARGET_DIR
delete_before_apply=${KR_DELETE_BEFORE_APPLY:-false}

updated_at=$(date +%s)

export_variables() {
  # Export normally here so they are available to the post hook
  export URL=$url
}

print_preinstall_message() {
  echo "Environment will be deployed with url: $url"

  if [ "$KR_MESSAGE" != "" ]; then
    printf "%s\n" "$KR_MESSAGE" "$KR_LOG_URL$namespace"
  fi
}

config_context() {
  # kubectl locks the config for each execution. To workaround
  # and allow multiple concurrent kubectl executions we copy the config
  scoped_kubeconfig_file=$kube_config_file-$namespace
  cp "$kube_config_file" "$scoped_kubeconfig_file"
  export KUBECONFIG=${scoped_kubeconfig_file}

  if [ "$kube_context" != "" ]; then
    kubectl config use-context "$kube_context"
  fi
}

install_resources () {
  # Prepare directory structure and copy files
  work_dir=$(mktemp -d)

  # If we don't have a overlay to apply, we just run from base overlay
  cp -R "$base_overlay_path" "$work_dir"
  if [ "$overlay_path" != "" ]; then
    cp -R "$overlay_path" "$work_dir"
  fi

  # Apply variable substituion on patches
  for f in "$work_dir"/**/patches/*.json
  do
    KR_NAMESPACE=$namespace \
    envsubst < "$f" | sponge "$f";
    if [ "$verbose" = "true" ]; then
      cat "$f"
    fi
	done

  # Accessing the folder with the kustomize files
  if [ "$overlay_target_dir" != "" ]; then
    echo "Accessing the $overlay_target_dir folder";
    cd "$work_dir/$overlay_target_dir"
  else
    echo "Accessing the base folder";
    cd "$work_dir"
  fi

  # Copy files to shared path if it is present
  if [ "$shared_path" != "" ]; then
    cp -R "$shared_path" "./__shared_path"
  fi

  kustomize edit set namespace "$namespace"
  kustomize edit add annotation --force \
  app.kubernetes.io/instance:"$namespace" \
  app.kubernetes.io/pull_request_number:"$pull_request_number" \
  app.kubernetes.io/branch_name:"$branch_name" \
  app.kubernetes.io/repository_name:"$repo_name" \
  app.kubernetes.io/repository_owner:"$repo_owner" \
  app.kubernetes.io/updated_at:"$updated_at" \
  app.kubernetes.io/is_ephemeral:"$is_ephemeral" \
  app.kubernetes.io/job_url:'"'$job_url'"'

  if [ "$delete_before_apply" != false ]; then
    kubectl delete namespace "$namespace" --wait=true --ignore-not-found=true
  fi

  fresh_install=0
  output=$(kubectl get deployment -n "$namespace" kube-review-deployment --ignore-not-found)
  if [[ $output = "" ]]; then \
    echo "First time deployment, rollout is not necessary"; \
    fresh_install=1; \
  fi

  # Apply changes generated by kustomize
  if [ "$verbose" = "true" ]; then
    if [ "$overlay_target_dir" != "" ]; then
      echo "[VERBOSE] Deploying the $overlay_target_dir folder";
      kustomize build $overlay_target_dir | kubectl apply -f - -n "$namespace" --wait=true
    else
      echo "[VERBOSE] Deploying the base folder";
      kustomize build base | kubectl apply -f - -n "$namespace" --wait=true
    fi
  else
    if [ "$overlay_target_dir" != "" ]; then
      echo "Deploying the $overlay_target_dir folder";
      kustomize build $overlay_target_dir | kubectl apply -f - -n "$namespace" --wait=true
    else
      echo "Deploying the base folder";
      kustomize build base | kubectl apply -f - -n "$namespace" --wait=true
    fi
  fi

  if [[ $fresh_install != 1 ]]; then
    # Rollout is necessary to force loading of secrets when only the secrets is updated
    echo "Re-deployment, executing rollout";
    kubectl rollout restart -n "$namespace" deployment/kube-review-deployment    
  fi

  if kubectl rollout status --timeout=10m -n "$namespace" deployment/kube-review-deployment; then
    echo "Rollout successfully executed"
  else
    echo "Rollout was not Successful... Describing Deployed Pods"
    kubectl -n "$namespace" describe pods
    echo "Showing Namespace Events"
    kubectl -n "$namespace" get events

    if [ "$verbose" = "false" ]; then
      exit 1;
    else
      echo "[VERBOSE] Showing Pods Logs"
      for pod_names in $(kubectl get pods --no-headers -o custom-columns=":metadata.name" -n "$namespace" --field-selector status.phase=Running)
      do
        echo "Logs from Pod '"$pod_names"'" "in" the Namespace "'"$namespace"':"
        kubectl -n "$namespace" logs "$pod_names" --all-containers=true
      done
      exit 1;
    fi
  fi
}

test_url() {
  if [ "$test_connection" = true ];
  then
    full_url=$url$test_connection_url_path
    echo "Running connection test against: $full_url"
    output=$(curl --silent --fail --max-time 10 --retry 10 --retry-delay 5 --retry-connrefused --retry-all-errors "$full_url")
    if [[ $? != 0 ]]; then
      echo "Connection test has failed with the following test output: $output";
      exit 1;
    else
      echo "Connection test executed successfully";
    fi
  else
    echo "Connection test is disabled";
  fi
}

export_variables
print_preinstall_message
config_context
install_resources
test_url

if [ "$KR_POST_HOOK" != "" ]; then
  echo "Running post hook command: $KR_POST_HOOK"
  eval "$KR_POST_HOOK"
fi
